package ^agent

import fr.utbm.info.ia51.framework.^agent.AbstractAnimat
import fr.utbm.info.ia51.framework.environment.DynamicType
import fr.utbm.info.ia51.framework.environment.Percept
import fr.utbm.info.ia51.framework.environment.PerceptionEvent
import fr.utbm.info.ia51.framework.math.MathUtil
import fr.utbm.info.ia51.general.motionalgo.KinematicSeekAlgorithm
import fr.utbm.info.ia51.general.motionalgo.KinematicWanderAlgorithm
import fr.utbm.info.ia51.general.motionalgo.SeekAlgorithm
import fr.utbm.info.ia51.general.motionalgo.SteeringSeekAlgorithm
import fr.utbm.info.ia51.general.motionalgo.SteeringWanderAlgorithm
import fr.utbm.info.ia51.general.motionalgo.WanderAlgorithm
import io.sarl.core.Initialize
import java.util.List
import java.util.ArrayList
import com.google.common.collect.Lists;

import fr.utbm.info.ia51.framework.math.Point2f
import fr.utbm.info.ia51.framework.math.Shape2f
import fr.utbm.info.ia51.framework.math.Vector2f

/** 
 * @author c
 * 
 */
@SuppressWarnings("discouraged_occurrence_readonly_use")
agent Visitor extends AbstractAnimat {

	// 差集
  // list1.removeAll(list2);
	var seekBehaviour : SeekAlgorithm
	var wanderBehaviour : WanderAlgorithm
	
	var visitedShop = new ArrayList<Percept>
	var currentTargetPosition = new Point2f
	var currentTargetVistedOrNot = true

	val STOP_RADIUS = MathUtil.PI / 10f
	val SLOW_RADIUS = MathUtil.PI / 4f
	val WANDER_CIRCLE_DISTANCE = 60f
	val WANDER_CIRCLE_RADIUS = 20f
	val WANDER_MAX_ROTATION = MathUtil.PI / 10f

	// This function is called from "on Initialize" in the super type.
	override overridableInitializationStage(it : Initialize) {
		super.overridableInitializationStage(it)
		if (this.behaviorType == DynamicType::STEERING) {
			this.seekBehaviour = new SteeringSeekAlgorithm
			this.wanderBehaviour = new SteeringWanderAlgorithm(WANDER_CIRCLE_DISTANCE, WANDER_CIRCLE_RADIUS,
				WANDER_MAX_ROTATION, STOP_RADIUS, SLOW_RADIUS)
		} else {
			this.seekBehaviour = new KinematicSeekAlgorithm
			this.wanderBehaviour = new KinematicWanderAlgorithm
		}
	}

	def extractTarget(percepts : List<Percept>) : Point2f { // class Percept implements MobileObject,
		var allShops = Lists.newArrayList(
			percepts.filter[it.type == "environment.ShopBody"]
		)
		if (this.currentTargetVistedOrNot) 
		{
			// 如果都去过了那就回家
			if (this.visitedShop.size() == allShops.size()) {
				var targetExits = percepts.filter[it.type == "environment.ExitBody"]
				var targetExit = targetExits.get(
					(Math.random() * targetExits.size()).intValue() // 如果有多个如口，可以随机生成在不同入口
				)
				currentTargetVistedOrNot = false
				return currentTargetPosition = targetExit.position.clone
			}
			// 如果这个商店 去过了 那就换一家店
			else {
				allShops.removeAll(this.visitedShop)
				var targetShop = allShops.get(
					(Math.random() * allShops.size()).intValue() // 如果有多个如口，可以随机生成在不同入口
				)
				this.visitedShop.add(targetShop)
				currentTargetPosition = targetShop.position.clone
				currentTargetVistedOrNot = false
				return targetShop.position
			}
		}
		else{
			//如果还没到想去的地方
			return this.currentTargetPosition		
		}
	}
	
//	def targetPositionReachDection(s : ): boolean
//	{// 目前是判断自己的身体部分有没有接触到这个点     圣体是一个圆
//		
//		var x = occurrence.body.shape.center.x - currentTargetPosition.x
//		var y = occurrence.body.shape.center.y - currentTargetPosition.y
//		
//		return ((x * x + y * y) < (occurrence.body.shape.radius * occurrence.body.shape.radius))
//	}

	on PerceptionEvent {
		// 判断想去的那个点  是否接触到自己的身体   ， 接触到了才算到达
		if (occurrence.body.shape.intersects(currentTargetPosition))
		{
			this.currentTargetVistedOrNot = true
		}
		//TODO: 判断到达出口后agent死亡
		
		var target = occurrence.perceptions.extractTarget
//1. 判断有无危险
//2. 判断会不会撞到  会的话就减速
//3. 
		if (target !== null) {
			// run the seek behaviour
			this.seekBehaviour.run(
				occurrence.body.position,
				occurrence.body.currentLinearSpeed,
				occurrence.body.maxLinear,
				target
			).emitInfluence 
			// emitInfluenct 用来计算influence
		} else {
			// doNothing
			// // run the wander behaviour
			this.wanderBehaviour.run(
				occurrence.body.position,
				occurrence.body.direction,
				occurrence.body.currentLinearSpeed,
				occurrence.body.maxLinear,
				occurrence.body.currentAngularSpeed,
				occurrence.body.maxAngular
			).emitInfluence
		}
	}
	
//	on collisionDected{
//		
	//	}

	//	on collisionDected{
	//
	//	}




}
