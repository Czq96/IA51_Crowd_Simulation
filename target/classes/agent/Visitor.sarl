package ^agent

import fr.utbm.info.ia51.framework.^agent.AbstractAnimat
import fr.utbm.info.ia51.framework.environment.DynamicType
import fr.utbm.info.ia51.framework.environment.Percept
import fr.utbm.info.ia51.framework.environment.PerceptionEvent
import fr.utbm.info.ia51.framework.math.MathUtil
import fr.utbm.info.ia51.general.motionalgo.KinematicSeekAlgorithm
import fr.utbm.info.ia51.general.motionalgo.KinematicWanderAlgorithm
import fr.utbm.info.ia51.general.motionalgo.SeekAlgorithm
import fr.utbm.info.ia51.general.motionalgo.SteeringSeekAlgorithm
import fr.utbm.info.ia51.general.motionalgo.SteeringWanderAlgorithm
import fr.utbm.info.ia51.general.motionalgo.WanderAlgorithm
import io.sarl.core.Initialize
import java.util.List
import java.util.ArrayList
import com.google.common.collect.Lists;

import fr.utbm.info.ia51.framework.math.Point2f
import fr.utbm.info.ia51.framework.math.Shape2f
import fr.utbm.info.ia51.framework.math.Vector2f

/** 
 * @author c
 * 
 */
agent Visitor extends AbstractAnimat {

	// 差集
  // list1.removeAll(list2);
	var seekBehaviour : SeekAlgorithm
	var wanderBehaviour : WanderAlgorithm
	var visitedShop = new ArrayList<Percept>
	var currentTargetPosition = new Point2f
	var currentTargetShopVistedOrNot = true

	val STOP_RADIUS = MathUtil.PI / 10f
	val SLOW_RADIUS = MathUtil.PI / 4f
	val WANDER_CIRCLE_DISTANCE = 60f
	val WANDER_CIRCLE_RADIUS = 20f
	val WANDER_MAX_ROTATION = MathUtil.PI / 10f

	// This function is called from "on Initialize" in the super type.
	override overridableInitializationStage(it : Initialize) {
		super.overridableInitializationStage(it)
		if (this.behaviorType == DynamicType::STEERING) {
			this.seekBehaviour = new SteeringSeekAlgorithm
			this.wanderBehaviour = new SteeringWanderAlgorithm(WANDER_CIRCLE_DISTANCE, WANDER_CIRCLE_RADIUS,
				WANDER_MAX_ROTATION, STOP_RADIUS, SLOW_RADIUS)
		} else {
			this.seekBehaviour = new KinematicSeekAlgorithm
			this.wanderBehaviour = new KinematicWanderAlgorithm
		}
	}

	def extractTarget(percepts : List<Percept>) : Point2f { // class Percept implements MobileObject,
		var allShops = Lists.newArrayList(
			percepts.filter[it.type == "environment.ShopBody"]
		)
		if (currentTargetShopVistedOrNot) // 如果这个商店 去过了 那就换一家店
		{
			if (this.visitedShop.size() == allShops.size()) {
				var targets = percepts.filter[it.type == "environment.ExitBody"]
				currentTargetPosition = targets.get(0).position.clone
				currentTargetShopVistedOrNot = false
				return targets.get(0).position
			}
			else {
				allShops.removeAll(this.visitedShop)
				var targetShop = allShops.get(
					(Math.random() * allShops.size()).intValue() // 如果有多个如口，可以随机生成在不同入口
				)
				this.visitedShop.add(targetShop)
				currentTargetPosition = targetShop.position.clone
				currentTargetShopVistedOrNot = false
				return targetShop.position
			}
		}
		else{
			return this.currentTargetPosition		
		}
	}
	

	on PerceptionEvent {
		
		var target = occurrence.perceptions.extractTarget
//1. 判断有无危险
//2. 判断会不会撞到  会的话就减速
//3. 
		if (target !== null) {
			// run the seek behaviour
			this.seekBehaviour.run(
				occurrence.body.position,
				occurrence.body.currentLinearSpeed,
				occurrence.body.maxLinear,
				target
			).emitInfluence 
			// emitInfluenct 用来计算influence
		} else {
			// doNothing
			// // run the wander behaviour
			this.wanderBehaviour.run(
				occurrence.body.position,
				occurrence.body.direction,
				occurrence.body.currentLinearSpeed,
				occurrence.body.maxLinear,
				occurrence.body.currentAngularSpeed,
				occurrence.body.maxAngular
			).emitInfluence
		}
	}
	
//	on collisionDected{
//		
	//	}

	//	on collisionDected{
	//
	//	}




}
