package environment

import fr.utbm.info.ia51.framework.environment.AbstractEnvironment
import fr.utbm.info.ia51.framework.environment.AgentBody
import fr.utbm.info.ia51.framework.environment.DynamicType
import fr.utbm.info.ia51.framework.environment.Influence
import fr.utbm.info.ia51.framework.environment.MotionInfluence
import fr.utbm.info.ia51.framework.environment.Percept
import fr.utbm.info.ia51.framework.environment.SituatedObject
import fr.utbm.info.ia51.framework.gui.WorldModelStateProvider
import fr.utbm.info.ia51.framework.math.Circle2f
import fr.utbm.info.ia51.framework.math.MathUtil
import fr.utbm.info.ia51.framework.math.Point2f
import fr.utbm.info.ia51.framework.math.Shape2f
import fr.utbm.info.ia51.framework.math.Vector2f
import fr.utbm.info.ia51.framework.time.StepTimeManager
import fr.utbm.info.ia51.framework.time.TimeManager
import fr.utbm.info.ia51.framework.util.CollectionUtil
import fr.utbm.info.ia51.general.frustum.CircleFrustum
import java.text.MessageFormat
import java.util.ArrayList
import java.util.Collection
import java.util.List
import java.util.UUID

/** 
 * Model of the world.
 *   
 */
class SquareMap extends AbstractEnvironment implements WorldModelStateProvider {

	static val VISITOR_SIZE = 20f // TODO: change to image
	static val SHOP_SIZE = 30f // TODO: change to image
	
	var churchBodyList = new ArrayList<ChurchBody> 
	var agentBodyList = new ArrayList<AgentBody> // 在AbstractEnvironment 中也有这个量，重复定义 
	var shopBodyList = new ArrayList<ShopBody>  
	var exitBodyList = new ArrayList<ExitBody> 
	var wallBodyList = new ArrayList<WallBody>
	var entranceBodyList = new ArrayList<EntranceBody>
	var mouseTarget : MouseTarget

	
	/** 
	 * @param width is the width of the world.
	 * @param height is the height of the world.
	 */
	new (width : float, height : float) {
		super(width, height, new StepTimeManager(500))
		//this.spatialList = new List<>()
	}

	def createShop(positionOnScreen : Point2f) {
		var id = UUID::randomUUID
		var frustum = new CircleFrustum(id, 10 * SHOP_SIZE)
		var body = new ShopBody(
			id, 
			new Circle2f(0f, 0f, SHOP_SIZE), // body
			5f, // max linear speed m/s
			0.5f, // max linear acceleration (m/s)/s
			MathUtil.PI / 4f, // max angular speed r/s
			MathUtil.PI / 10f, // max angular acceleration (r/s)/s
			frustum)
		body.name = MessageFormat::format("Shop #{0}", this.shopBodyNumber + 1)
		addShopBody(
			body, 
			positionOnScreen, //real position
		Math::random as float * MathUtil.TWO_PI)
		// TODO: randomPosition 放置在 exit 的地方
	}

	def createVisitor {
		var id = UUID::randomUUID
		var frustum = new CircleFrustum(id, 10 * VISITOR_SIZE)
		var body = new AgentBody(
			id,
			new Circle2f(0f, 0f, VISITOR_SIZE), // body
			5f, // max linear speed m/s
			0.5f, // max linear acceleration (m/s)/s
			MathUtil.PI / 4f, // max angular speed r/s
			MathUtil.PI / 10f, // max angular acceleration (r/s)/s
			frustum)
		body.name = MessageFormat::format("Visitor #{0}", this.agentBodyNumber + 1)
		addAgentBody(
			body, 
			randomPosition,// TODO: 初始化的地址要在公园的入口
			Math::random as float * MathUtil.TWO_PI)
	}

   def createChurch  {

		var id = UUID::randomUUID
		var frustum = new CircleFrustum(id, 10 * SHOP_SIZE)
		var body :ChurchBody = new ChurchBody(id, new Circle2f(0f, 0f, SHOP_SIZE), // body
			5f, // max linear speed m/s
			0.5f, // max linear acceleration (m/s)/s
			MathUtil.PI / 4f, // max angular speed r/s
			MathUtil.PI / 10f, // max angular acceleration (r/s)/s
			frustum)
		body.name = MessageFormat::format("Church #{0}", this.shopBodyNumber + 1)
		addChurchBody(
			body, 
			new Point2f(325f,675f), //real position
			Math::random as float * MathUtil.TWO_PI)
	
	}

	def createWall(positionOnScreen : Point2f) {

		var id = UUID::randomUUID
		var frustum = new CircleFrustum(id, 10 * SHOP_SIZE)
		var body : WallBody = new WallBody(id, new Circle2f(0f, 0f, SHOP_SIZE), // body
		5f, // max linear speed m/s
		0.5f, // max linear acceleration (m/s)/s
		MathUtil.PI / 4f, // max angular speed r/s
		MathUtil.PI / 10f, // max angular acceleration (r/s)/s
			frustum)
		body.name = MessageFormat::format("Wall #{0}", this.wallBodyNumber + 1)
		addWallBody(body, positionOnScreen, //real position
		Math::random as float * MathUtil.TWO_PI)

	}

	def createExit(positionOnScreen : Point2f) {

		var id = UUID::randomUUID
		var frustum = new CircleFrustum(id, 10 * SHOP_SIZE)
		var body : ExitBody = new ExitBody(id, new Circle2f(0f, 0f, SHOP_SIZE), // body
		5f, // max linear speed m/s
		0.5f, // max linear acceleration (m/s)/s
		MathUtil.PI / 4f, // max angular speed r/s
		MathUtil.PI / 10f, // max angular acceleration (r/s)/s
		frustum)
		body.name = MessageFormat::format("Exit #{0}", this.exitBodyNumber + 1)
		addExitBody(body, positionOnScreen, // real position
		Math::random as float * MathUtil.TWO_PI)

	}

	def createEntrance (positionOnScreen : Point2f) {

		var id = UUID::randomUUID
		var frustum = new CircleFrustum(id, 10 * SHOP_SIZE)
		var body : EntranceBody = new EntranceBody(id, new Circle2f(0f, 0f, SHOP_SIZE), // body
		5f, // max linear speed m/s
		0.5f, // max linear acceleration (m/s)/s
		MathUtil.PI / 4f, // max angular speed r/s
		MathUtil.PI / 10f, // max angular acceleration (r/s)/s
		frustum)
		body.name = MessageFormat::format("Entrance #{0}", this.entranceBodyNumber + 1)
		addEntranceBody(body, positionOnScreen, // real position
		Math::random as float * MathUtil.TWO_PI)

	}

	protected def randomPosition : Point2f {
		var x = Math::random as float * this.width - VISITOR_SIZE
		var y = Math.random() as float * this.height - VISITOR_SIZE
		return new Point2f(x, y)
	}

	 protected def onAgentBodyCreated(body : AgentBody) {
		this.agentBodyList.add(body) // initialize visitor
	}

	protected def onShopBodyCreated(body : ShopBody) {
		this.shopBodyList.add(body) 	// initialize shop
	}

	protected def onChurchBodyCreated(body : ChurchBody) {
		this.churchBodyList.add(body)
	}

	protected def onWallBodyCreated(body : WallBody) {
		this.wallBodyList.add(body)
	}

	protected def onExitBodyCreated(body : ExitBody) {
		this.exitBodyList.add(body)
	}

	protected def onEntranceBodyCreated(body : EntranceBody) {
		this.entranceBodyList.add(body)
	}
	protected def onAgentBodyDestroyed(body : AgentBody) {
		throw new UnsupportedOperationException("TODO: onAgentBodyDestroyed")
	}
	
	// 运行behavior后的状态
	protected def computeEndogenousBehaviorInfluences : List<Influence> {
		emptyList
	}
	
	protected def computePerceptionsFor(^agent : AgentBody) : List<Percept> {
		var allPercepts = new ArrayList<Percept>
		return allPercepts
	}
	
//	protected def applyInfluences(motionInfluences : Collection<MotionInfluence>,
//		otherInfluences : Collection<Influence>, timeManager : TimeManager) {
//		var actions = new ArrayList<AnimatAction>(motionInfluences.size());
//		for (index1 : 0 ..< motionInfluences.size) {
//			var inf1 = motionInfluences.get(index1)
//			var body1 = getAgentBodyFor(inf1.emitter)
//			var move : Vector2f
//			var rotation : float
//			if (inf1.type === DynamicType.STEERING) {
//				move = body1.computeSteeringTranslation(inf1.linearInfluence, timeManager)
//				rotation = body1.computeSteeringRotation(inf1.angularInfluence, timeManager)
//			} else {
//				move = body1.computeKinematicTranslation(inf1.linearInfluence, timeManager)
//				rotation = body1.computeKinematicRotation(inf1.angularInfluence, timeManager)
//			}
//
//			actions += new AnimatAction(body1, move, rotation)
//
//		}
//
//		// Apply the actions
//		for (action : actions) {
//			var body = action.objectToMove
//			if (body !== null) {
//				body.move(action.translation, action.rotation)
//			}
//		}
//	
//	}

	override applyInfluences(motionInfluences : Collection<MotionInfluence>, otherInfluences : Collection<Influence>,
		timeManager : TimeManager) {
		var influenceList = new ArrayList<MotionInfluence>(motionInfluences)
		var actions = new ArrayList<AnimatAction>(influenceList.size)

		// Compute actions
		for (index1 : 0 ..< influenceList.size) {
			var inf1 = influenceList.get(index1)
			var body1 = getAgentBodyFor(inf1.emitter)
			if (body1 !== null) {
				var move : Vector2f
				var rotation : float
				if (inf1.type === DynamicType::STEERING) {
					move = body1.computeSteeringTranslation(inf1.linearInfluence, timeManager)
					rotation = body1.computeSteeringRotation(inf1.angularInfluence, timeManager)
				} else {
					move = body1.computeKinematicTranslation(inf1.linearInfluence, timeManager)
					rotation = body1.computeKinematicRotation(inf1.angularInfluence, timeManager)
				}

				var body1Bounds = body1.shape

				// Trivial collision detection
				trivialCollisionDetection(index1, influenceList, body1Bounds, move)

				actions += new AnimatAction(body1, move, rotation)

			}
		}

		// Apply the actions
		for (action : actions) {
			var body = action.objectToMove
			if (body !== null) {
				body.move(action.translation, action.rotation)
			}
		}
	}

	private def trivialCollisionDetection(index1 : int, influenceList : List<MotionInfluence>, body1Bounds : Shape2f<?>,
		move : Vector2f) {
		for (index2 : (index1 + 1) ..< influenceList.size) {
			var inf2 = influenceList.get(index2)
			var body2 = getAgentBodyFor(inf2.emitter)
			if (body2 !== null) {
				val body2Bounds = body2.shape
				if (body1Bounds.intersects(body2Bounds)) {
					move.set(0, 0)
					return
				}
			}
		}
	}
	
	def getAllObjects : Iterable<? extends SituatedObject> {	
		if (this.mouseTarget !== null) {
			return CollectionUtil.newIterable(this.agentBodies + this.shopBodies + this.churchBodies+this.wallBodies+this.exitBodies+this.entranceBodies, this.mouseTarget)
		}
		return this.agentBodies + this.shopBodies + this.churchBodies + this.wallBodies + this.exitBodies +
			this.entranceBodies
	}

	override setMouseTarget(target : Point2f) {
		if (target === null) {
			var r = randomPosition
			this.mouseTarget = new MouseTarget(r.x, r.y)  
		}
		else 
			this.mouseTarget = new MouseTarget(target.x, target.y)
	}
	
	
	private static class AnimatAction {

		val body : AgentBody
		val move : Vector2f
		val rotation : float

		/** 
		 * @param object is the animat body.
		 * @param move is the translation.
		 * @param rotation is the rotation.
		 */
		new (object : AgentBody, move : Vector2f, rotation : float) {
			this.body = object
			this.move = move
			this.rotation = rotation
		}

		/** Replies the moved object.
		 * 
		 * @return the moved object.
		 */
		def getObjectToMove : AgentBody {
			this.body
		}

		/** Replies the translation.
		 * 
		 * @return the translation.
		 */
		def getTranslation : Vector2f {
			this.move
		}

		/** Replies the rotation.
		 * 
		 * @return the rotation.
		 */
		def getRotation : float {
			this.rotation
		}

	}
	
	
}
