package environment

import fr.utbm.info.ia51.framework.environment.AbstractEnvironment
import fr.utbm.info.ia51.framework.environment.AgentBody // 生成了小兔子
import fr.utbm.info.ia51.framework.environment.DynamicType
import fr.utbm.info.ia51.framework.environment.Influence
import fr.utbm.info.ia51.framework.environment.MotionInfluence
import fr.utbm.info.ia51.framework.environment.Percept
import fr.utbm.info.ia51.framework.environment.SituatedObject
import fr.utbm.info.ia51.framework.gui.WorldModelStateProvider
import fr.utbm.info.ia51.framework.math.Circle2f
import fr.utbm.info.ia51.framework.math.MathUtil
import fr.utbm.info.ia51.framework.math.Point2f
import fr.utbm.info.ia51.framework.math.Rectangle2f
import fr.utbm.info.ia51.framework.math.Shape2f
import fr.utbm.info.ia51.framework.math.Vector2f
import fr.utbm.info.ia51.framework.time.StepTimeManager
import fr.utbm.info.ia51.framework.time.TimeManager
import fr.utbm.info.ia51.framework.util.CollectionUtil
import fr.utbm.info.ia51.general.frustum.CircleFrustum
import java.util.ArrayList
import java.util.Collection
import java.util.List
import java.util.UUID
import java.text.MessageFormat
import java.util.ArrayList;
import fr.utbm.info.ia51.framework.environment.AbstractSituatedObject

/** 
 * Model of the world.
 *   
 */
class SquareMap extends AbstractEnvironment implements WorldModelStateProvider {

	static val VISITOR_SIZE = 20f // TODO: change to image
	static val SHOP_SIZE = 20f // TODO: change to image
	

	var agentBodyList = new ArrayList<AgentBody> // 在AbstractEnvironment 中也有这个量，重复定义 
	var shopBodyList = new ArrayList<ShopBody>  
	
	var mouseTarget : MouseTarget

	
	/** 
	 * @param width is the width of the world.
	 * @param height is the height of the world.
	 */
	new (width : float, height : float) {
		super(width, height, new StepTimeManager(500))
		//this.spatialList = new List<>()
	}

	def createShop {
		var id = UUID::randomUUID
		var frustum = new CircleFrustum(id, 10 * SHOP_SIZE)
		var body = new ShopBody(
			id, 
			new Circle2f(0f, 0f, SHOP_SIZE), // body
			5f, // max linear speed m/s
			0.5f, // max linear acceleration (m/s)/s
			MathUtil.PI / 4f, // max angular speed r/s
			MathUtil.PI / 10f, // max angular acceleration (r/s)/s
			frustum)
		body.name = MessageFormat::format("Shop #{0}", this.shopBodyNumber + 1)
		addShopBody(
			body, 
			randomPosition, 
			Math::random as float * MathUtil.TWO_PI)
		// TODO: randomPosition s
	}

	def createVisitor {
		var id = UUID::randomUUID
		var frustum = new CircleFrustum(id, 10 * VISITOR_SIZE)
		var body = new AgentBody(
			id,
			new Circle2f(0f, 0f, VISITOR_SIZE), // body
			5f, // max linear speed m/s
			0.5f, // max linear acceleration (m/s)/s
			MathUtil.PI / 4f, // max angular speed r/s
			MathUtil.PI / 10f, // max angular acceleration (r/s)/s
			frustum)
		body.name = MessageFormat::format("Visitor #{0}", this.agentBodyNumber + 1)
		addAgentBody(
			body, 
			randomPosition,// TODO: 初始化的地址要在公园的入口
			Math::random as float * MathUtil.TWO_PI)
	}

	protected def randomPosition : Point2f {
		var x = Math::random as float * this.width - VISITOR_SIZE
		var y = Math.random() as float * this.height - VISITOR_SIZE
		return new Point2f(x, y)
	}

	 protected def onAgentBodyCreated(body : AgentBody) {
		this.agentBodyList.add(body) // initialize visitor
	}

	protected def onShopBodyCreated(body : ShopBody) {
		this.shopBodyList.add(body) 	// initialize shop
	}
	
	protected def onAgentBodyDestroyed(body : AgentBody) {
		throw new UnsupportedOperationException("TODO: onAgentBodyDestroyed")
	}
	
	// 运行behavior后的状态
	protected def computeEndogenousBehaviorInfluences : List<Influence> {
		emptyList
	}
	
	protected def computePerceptionsFor(^agent : AgentBody) : List<Percept> {
		var allPercepts = new ArrayList<Percept>
		
		
		return allPercepts
	}
	
	protected def applyInfluences(motionInfluences : Collection<MotionInfluence>,
		otherInfluences : Collection<Influence>, timeManager : TimeManager) {
		var actions = new ArrayList<AnimatAction>(motionInfluences.size());
		for (index1 : 0 ..< motionInfluences.size) {
			var inf1 = motionInfluences.get(index1)
			var body1 = getAgentBodyFor(inf1.emitter)
			var move : Vector2f
			var rotation : float
			if (inf1.type === DynamicType.STEERING) {
				move = body1.computeSteeringTranslation(inf1.linearInfluence, timeManager)
				rotation = body1.computeSteeringRotation(inf1.angularInfluence, timeManager)
			} else {
				move = body1.computeKinematicTranslation(inf1.linearInfluence, timeManager)
				rotation = body1.computeKinematicRotation(inf1.angularInfluence, timeManager)
			}

			actions += new AnimatAction(body1, move, rotation)

		}

		// Apply the actions
		for (action : actions) {
			var body = action.objectToMove
			if (body !== null) {
				body.move(action.translation, action.rotation)
			}
		}
	
	}

	private def trivialCollisionDetection(index1 : int, influenceList : List<MotionInfluence>, body1Bounds : Shape2f<?>,
		move : Vector2f) {
		for (index2 : (index1 + 1) ..< influenceList.size) {
			var inf2 = influenceList.get(index2)
			var body2 = getAgentBodyFor(inf2.emitter)
			if (body2 !== null) {
				val body2Bounds = body2.shape
				if (body1Bounds.intersects(body2Bounds)) {
					move.set(0, 0)
					return
				}
			}
		}
	}
	
	def getAllObjects : Iterable<? extends SituatedObject> {
		
//		var allObj : Iterable<AbstractSituatedObject> 
//		if (this.mouseTarget !== null) {
//			allObj= CollectionUtil.newIterable(this.agentBodies, this.mouseTarget)
//		}
//		
//		for(shop : this.shopBodies)
//		{
//			allObj = CollectionUtil.newIterable(allObj, shop)
//		}
////		
		if (this.mouseTarget !== null) {
			return CollectionUtil.newIterable(this.agentBodies + this.shopBodies, this.mouseTarget)
		}
		return this.agentBodies+this.shopBodies

//		return allObj
			}

	override setMouseTarget(target : Point2f) {
		if (target === null) {
			var r = randomPosition
			this.mouseTarget = new MouseTarget(r.x, r.y)  
		}
		else 
			this.mouseTarget = new MouseTarget(target.x, target.y)
	}
	
	
	private static class AnimatAction {

		val body : AgentBody
		val move : Vector2f
		val rotation : float

		/** 
		 * @param object is the animat body.
		 * @param move is the translation.
		 * @param rotation is the rotation.
		 */
		new (object : AgentBody, move : Vector2f, rotation : float) {
			this.body = object
			this.move = move
			this.rotation = rotation
		}

		/** Replies the moved object.
		 * 
		 * @return the moved object.
		 */
		def getObjectToMove : AgentBody {
			this.body
		}

		/** Replies the translation.
		 * 
		 * @return the translation.
		 */
		def getTranslation : Vector2f {
			this.move
		}

		/** Replies the rotation.
		 * 
		 * @return the rotation.
		 */
		def getRotation : float {
			this.rotation
		}

	}
	
	
}
